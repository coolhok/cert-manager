Creating a simple Vault based issuer
====================================

cert-manager can be used to obtain certificates from `Hashicorp's
Vault <https://www.vaultproject.io/>`__.

Vault Installation
==================

To install Vault your best course of action is to follow the official
`documentation <https://www.vaultproject.io/intro/getting-started/deploy.html>`__.

Vault PKI Backend
=================

The PKI Secrets Engine needs to be initialized for cert-manager to be
able to generate certificate. The official Vault documentation can be
found
`here <https://www.vaultproject.io/docs/secrets/pki/index.html>`__.

Supported Vault Authentication
==============================

The issuer can authenticate to Vault with a secret containing:
- a Vault token
- a Vault appRole/secretId

Vault AppRole
-------------

A `Vault AppRole <https://www.vaultproject.io/docs/auth/approle.html>`__
is the easiest way to authenticate securely to Vault with cert-manager. The secret
ID is stored in a secret.

For example:

.. code:: yaml

    apiVersion: v1
    kind: Secret
    type: Opaque
    metadata:
      name: cert-manager-vault-approle
      namespace: kube-system
    data:
      secretId: "MDI..."

Where the secretId is the base 64 encoded value of the appRole *secretId*
giving access to the pki backend in Vault.

We can now create a cluster issuer referencing this secret:

.. code:: yaml

    apiVersion: certmanager.k8s.io/v1alpha1
    kind: ClusterIssuer
    metadata:
      name: vault-cluster-issuer
    spec:
      vault:
        path: pki_int/sign/example-dot-com
        server: https://vault
        auth:
          appRole:
            roleId: "291b9d21-8ff5-..."
            secretRef:
              name: cert-manager-vault-approle
              key: secretId

Where *path* is the Vault role path of the PKI backend and *server* is
the Vault server base URL. The Vault appRole credentials are supplied as the
Vault authentication method using the appRole created in Vault. The secretRef
references the Kubernetes secret created previously. More specifically, the field
*name* is the Kubernetes secret name and *key* is the name given as the
key value that store the *secretId*.

Vault Token
-----------

This Vault authentication method uses a plain token. A Vault token is generated by
one of the many authentication backend supported by Vault. Tokens in Vault have
expiration and need to be refreshed.  You need to be aware that cert-manager do not
refresh these tokens. Another process must be put in place to keep them from expiring.

For testing purpose a root token which do not expire is generated at Vault installation
time. Beware, *a root token should only be used for testing purpose only*.

Please refer to the official token `Vault documentation <https://www.vaultproject.io/docs/concepts/tokens.html>`__
for all the details.

The secret containing the token must have a key named token. Here an
example:

.. code:: yaml

    apiVersion: v1
    kind: Secret
    type: Opaque
    metadata:
      name: cert-manager-vault-token
      namespace: kube-system
    data:
      token: "MjI..."

Where the token value is the base 64 encoded value of the token giving
access to the PKI backend in Vault.

We can now create an issuer referencing this secret:

.. code:: yaml

    apiVersion: certmanager.k8s.io/v1alpha1
    kind: ClusterIssuer
    metadata:
      name: vault-cluster-issuer
    spec:
      vault:
        auth:
          tokenSecretRef:
            name: cert-manager-vault-token
            key: token
        path: pki_int/sign/example-dot-com
        server: https://vault

Where *path* is the Vault role path of the PKI backend and *server* is
the Vault server base URL. The secret created previously is referenced in the issuer
with its *name* and *key* corresponding to the name of the Kubernetes secret and the
property name containing the token value respectively.

