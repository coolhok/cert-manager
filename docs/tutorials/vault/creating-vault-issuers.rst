Vault Installation
==================

Installing Vault
----------------

Vault installation is a complex subject. For a thorough tour of the subject
you can read the official Hashicorp Vault
`documentation <https://www.vaultproject.io/intro/getting-started/install.html>`__.


Vault PKI Backend
-----------------

The PKI Secrets Engine needs to be initialized for cert-manager to be
able to generate certificate. The official Vault documentation can be
found
`here <https://www.vaultproject.io/docs/secrets/pki/index.html>`__.

Vault Authentication with a AppRole
===================================

This Vault authentication method uses a
`Vault AppRole <https://www.vaultproject.io/docs/auth/approle.html>`__.

The secret ID of the AppRole is stored in a secret.

Here an example of a secret containing the secretId of the AppRole:

.. code:: yaml

    apiVersion: v1
    kind: Secret
    type: Opaque
    metadata:
      name: cert-manager-vault-approle
      namespace: kube-system
    data:
      secretId: "MDI..."

Where the secretId is the base 64 encoded value of the appRole *secretId*
giving access to the pki backend in Vault.

We can now create a cluster issuer referencing this secret:

.. code:: yaml

    apiVersion: certmanager.k8s.io/v1alpha1
    kind: ClusterIssuer
    metadata:
      name: vault-cluster-issuer
    spec:
      vault:
        path: pki_int/sign/example-dot-com
        server: https://vault
        auth:
          appRole:
            roleId: "291b9d21-8ff5-..."
            secretRef:
              name: cert-manager-vault-approle
              key: secretId

Where *path* is the Vault role path of the PKI backend and *server* is
the Vault server base URL. The Vault appRole credentials are supplied as the
Vault authentication method using the appRole created in Vault. The secretRef
references the Kubernetes secret created previously. More specifically, the field
*name* is the Kubernetes secret name and *key* is the name given as the
key value that store the *secretId*.

Vault Authentication with a Token
=================================

This Vault authentication method uses a plain token. A Vault token is generated by
one of the many authentication backend supported by Vault. Tokens in Vault have
expiration and need to be refreshed.  You need to be aware that cert-manager do not
refresh these tokens. Another process must be put in place to keep them from expiring.

For testing purpose a root token which do not expire is generated at Vault installation
time. Beware, *a root token should only be used for testing purpose only*.

Please refer to the official token `documentation <https://www.vaultproject.io/docs/concepts/tokens.html>`__
for all the details.

Here an example of a secret Kubernetes resource containing the Vault token:

.. code:: yaml

    apiVersion: v1
    kind: Secret
    type: Opaque
    metadata:
      name: cert-manager-vault-token
      namespace: kube-system
    data:
      token: "MjI..."

Where the token value is the base 64 encoded value of the token giving
access to the PKI backend in Vault.

We can now create an issuer referencing this secret:

.. code:: yaml

    apiVersion: certmanager.k8s.io/v1alpha1
    kind: ClusterIssuer
    metadata:
      name: vault-cluster-issuer
    spec:
      vault:
        auth:
          tokenSecretRef:
            name: cert-manager-vault-token
            key: token
        path: pki_int/sign/example-dot-com
        server: https://vault

Where *path* is the Vault role path of the PKI backend and *server* is
the Vault server base URL. The secret created previously is referenced in the issuer
with its *name* and *key* corresponding to the name of the Kubernetes secret and the
property name containing the token value respectively.

